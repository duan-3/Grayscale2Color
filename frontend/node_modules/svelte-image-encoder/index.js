(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = global || self, global.ImgEncoder = factory());
}(this, function () { 'use strict';

	function unwrapExports (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var internal = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, '__esModule', { value: true });

	function noop() {}

	const identity = x => x;

	function assign(tar, src) {
		for (const k in src) tar[k] = src[k];
		return tar;
	}

	function is_promise(value) {
		return value && typeof value.then === 'function';
	}

	function add_location(element, file, line, column, char) {
		element.__svelte_meta = {
			loc: { file, line, column, char }
		};
	}

	function run(fn) {
		return fn();
	}

	function blank_object() {
		return Object.create(null);
	}

	function run_all(fns) {
		fns.forEach(run);
	}

	function is_function(thing) {
		return typeof thing === 'function';
	}

	function safe_not_equal(a, b) {
		return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
	}

	function not_equal(a, b) {
		return a != a ? b == b : a !== b;
	}

	function validate_store(store, name) {
		if (!store || typeof store.subscribe !== 'function') {
			throw new Error(`'${name}' is not a store with a 'subscribe' method`);
		}
	}

	function subscribe(component, store, callback) {
		component.$$.on_destroy.push(store.subscribe(callback));
	}

	function create_slot(definition, ctx, fn) {
		if (definition) {
			const slot_ctx = get_slot_context(definition, ctx, fn);
			return definition[0](slot_ctx);
		}
	}

	function get_slot_context(definition, ctx, fn) {
		return definition[1]
			? assign({}, assign(ctx.$$scope.ctx, definition[1](fn ? fn(ctx) : {})))
			: ctx.$$scope.ctx;
	}

	function get_slot_changes(definition, ctx, changed, fn) {
		return definition[1]
			? assign({}, assign(ctx.$$scope.changed || {}, definition[1](fn ? fn(changed) : {})))
			: ctx.$$scope.changed || {};
	}

	function exclude_internal_props(props) {
		const result = {};
		for (const k in props) if (k[0] !== '$') result[k] = props[k];
		return result;
	}

	const tasks = new Set();
	let running = false;

	function run_tasks() {
		tasks.forEach(task => {
			if (!task[0](window.performance.now())) {
				tasks.delete(task);
				task[1]();
			}
		});

		running = tasks.size > 0;
		if (running) requestAnimationFrame(run_tasks);
	}

	function clear_loops() {
		// for testing...
		tasks.forEach(task => tasks.delete(task));
		running = false;
	}

	function loop(fn) {
		let task;

		if (!running) {
			running = true;
			requestAnimationFrame(run_tasks);
		}

		return {
			promise: new Promise(fulfil => {
				tasks.add(task = [fn, fulfil]);
			}),
			abort() {
				tasks.delete(task);
			}
		};
	}

	function append(target, node) {
		target.appendChild(node);
	}

	function insert(target, node, anchor) {
		target.insertBefore(node, anchor);
	}

	function detach(node) {
		node.parentNode.removeChild(node);
	}

	function detach_between(before, after) {
		while (before.nextSibling && before.nextSibling !== after) {
			before.parentNode.removeChild(before.nextSibling);
		}
	}

	function detach_before(after) {
		while (after.previousSibling) {
			after.parentNode.removeChild(after.previousSibling);
		}
	}

	function detach_after(before) {
		while (before.nextSibling) {
			before.parentNode.removeChild(before.nextSibling);
		}
	}

	function destroy_each(iterations, detaching) {
		for (let i = 0; i < iterations.length; i += 1) {
			if (iterations[i]) iterations[i].d(detaching);
		}
	}

	function element(name) {
		return document.createElement(name);
	}

	function svg_element(name) {
		return document.createElementNS('http://www.w3.org/2000/svg', name);
	}

	function text(data) {
		return document.createTextNode(data);
	}

	function space() {
		return text(' ');
	}

	function empty() {
		return text('');
	}

	function listen(node, event, handler, options) {
		node.addEventListener(event, handler, options);
		return () => node.removeEventListener(event, handler, options);
	}

	function prevent_default(fn) {
		return function(event) {
			event.preventDefault();
			return fn.call(this, event);
		};
	}

	function stop_propagation(fn) {
		return function(event) {
			event.stopPropagation();
			return fn.call(this, event);
		};
	}

	function attr(node, attribute, value) {
		if (value == null) node.removeAttribute(attribute);
		else node.setAttribute(attribute, value);
	}

	function set_attributes(node, attributes) {
		for (const key in attributes) {
			if (key === 'style') {
				node.style.cssText = attributes[key];
			} else if (key in node) {
				node[key] = attributes[key];
			} else {
				attr(node, key, attributes[key]);
			}
		}
	}

	function set_custom_element_data(node, prop, value) {
		if (prop in node) {
			node[prop] = value;
		} else {
			attr(node, prop, value);
		}
	}

	function xlink_attr(node, attribute, value) {
		node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);
	}

	function get_binding_group_value(group) {
		const value = [];
		for (let i = 0; i < group.length; i += 1) {
			if (group[i].checked) value.push(group[i].__value);
		}
		return value;
	}

	function to_number(value) {
		return value === '' ? undefined : +value;
	}

	function time_ranges_to_array(ranges) {
		const array = [];
		for (let i = 0; i < ranges.length; i += 1) {
			array.push({ start: ranges.start(i), end: ranges.end(i) });
		}
		return array;
	}

	function children(element) {
		return Array.from(element.childNodes);
	}

	function claim_element(nodes, name, attributes, svg) {
		for (let i = 0; i < nodes.length; i += 1) {
			const node = nodes[i];
			if (node.nodeName === name) {
				for (let j = 0; j < node.attributes.length; j += 1) {
					const attribute = node.attributes[j];
					if (!attributes[attribute.name]) node.removeAttribute(attribute.name);
				}
				return nodes.splice(i, 1)[0]; // TODO strip unwanted attributes
			}
		}

		return svg ? svg_element(name) : element(name);
	}

	function claim_text(nodes, data) {
		for (let i = 0; i < nodes.length; i += 1) {
			const node = nodes[i];
			if (node.nodeType === 3) {
				node.data = data;
				return nodes.splice(i, 1)[0];
			}
		}

		return text(data);
	}

	function set_data(text, data) {
		data = '' + data;
		if (text.data !== data) text.data = data;
	}

	function set_input_type(input, type) {
		try {
			input.type = type;
		} catch (e) {
			// do nothing
		}
	}

	function set_style(node, key, value) {
		node.style.setProperty(key, value);
	}

	function select_option(select, value) {
		for (let i = 0; i < select.options.length; i += 1) {
			const option = select.options[i];

			if (option.__value === value) {
				option.selected = true;
				return;
			}
		}
	}

	function select_options(select, value) {
		for (let i = 0; i < select.options.length; i += 1) {
			const option = select.options[i];
			option.selected = ~value.indexOf(option.__value);
		}
	}

	function select_value(select) {
		const selected_option = select.querySelector(':checked') || select.options[0];
		return selected_option && selected_option.__value;
	}

	function select_multiple_value(select) {
		return [].map.call(select.querySelectorAll(':checked'), option => option.__value);
	}

	function add_resize_listener(element, fn) {
		if (getComputedStyle(element).position === 'static') {
			element.style.position = 'relative';
		}

		const object = document.createElement('object');
		object.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden; pointer-events: none; z-index: -1;');
		object.type = 'text/html';

		let win;

		object.onload = () => {
			win = object.contentDocument.defaultView;
			win.addEventListener('resize', fn);
		};

		if (/Trident/.test(navigator.userAgent)) {
			element.appendChild(object);
			object.data = 'about:blank';
		} else {
			object.data = 'about:blank';
			element.appendChild(object);
		}

		return {
			cancel: () => {
				win && win.removeEventListener && win.removeEventListener('resize', fn);
				element.removeChild(object);
			}
		};
	}

	function toggle_class(element, name, toggle) {
		element.classList[toggle ? 'add' : 'remove'](name);
	}

	function custom_event(type, detail) {
		const e = document.createEvent('CustomEvent');
		e.initCustomEvent(type, false, false, detail);
		return e;
	}

	let stylesheet;
	let active = 0;
	let current_rules = {};

	// https://github.com/darkskyapp/string-hash/blob/master/index.js
	function hash(str) {
		let hash = 5381;
		let i = str.length;

		while (i--) hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
		return hash >>> 0;
	}

	function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
		const step = 16.666 / duration;
		let keyframes = '{\n';

		for (let p = 0; p <= 1; p += step) {
			const t = a + (b - a) * ease(p);
			keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
		}

		const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
		const name = `__svelte_${hash(rule)}_${uid}`;

		if (!current_rules[name]) {
			if (!stylesheet) {
				const style = element('style');
				document.head.appendChild(style);
				stylesheet = style.sheet;
			}

			current_rules[name] = true;
			stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
		}

		const animation = node.style.animation || '';
		node.style.animation = `${animation ? `${animation}, ` : ``}${name} ${duration}ms linear ${delay}ms 1 both`;

		active += 1;
		return name;
	}

	function delete_rule(node, name) {
		node.style.animation = (node.style.animation || '')
			.split(', ')
			.filter(name
				? anim => anim.indexOf(name) < 0 // remove specific animation
				: anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
			)
			.join(', ');

		if (name && !--active) clear_rules();
	}

	function clear_rules() {
		requestAnimationFrame(() => {
			if (active) return;
			let i = stylesheet.cssRules.length;
			while (i--) stylesheet.deleteRule(i);
			current_rules = {};
		});
	}

	function create_animation(node, from, fn, params) {
		if (!from) return noop;

		const to = node.getBoundingClientRect();
		if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom) return noop;

		const {
			delay = 0,
			duration = 300,
			easing = identity,
			start: start_time = window.performance.now() + delay,
			end = start_time + duration,
			tick = noop,
			css
		} = fn(node, { from, to }, params);

		let running = true;
		let started = false;
		let name;

		const css_text = node.style.cssText;

		function start() {
			if (css) {
				if (delay) node.style.cssText = css_text; // TODO create delayed animation instead?
				name = create_rule(node, 0, 1, duration, 0, easing, css);
			}

			started = true;
		}

		function stop() {
			if (css) delete_rule(node, name);
			running = false;
		}

		loop(now => {
			if (!started && now >= start_time) {
				start();
			}

			if (started && now >= end) {
				tick(1, 0);
				stop();
			}

			if (!running) {
				return false;
			}

			if (started) {
				const p = now - start_time;
				const t = 0 + 1 * easing(p / duration);
				tick(t, 1 - t);
			}

			return true;
		});

		if (delay) {
			if (css) node.style.cssText += css(0, 1);
		} else {
			start();
		}

		tick(0, 1);

		return stop;
	}

	function fix_position(node) {
		const style = getComputedStyle(node);

		if (style.position !== 'absolute' && style.position !== 'fixed') {
			const { width, height } = style;
			const a = node.getBoundingClientRect();
			node.style.position = 'absolute';
			node.style.width = width;
			node.style.height = height;
			const b = node.getBoundingClientRect();

			if (a.left !== b.left || a.top !== b.top) {
				const style = getComputedStyle(node);
				const transform = style.transform === 'none' ? '' : style.transform;

				node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;
			}
		}
	}

	function set_current_component(component) {
		exports.current_component = component;
	}

	function get_current_component() {
		if (!exports.current_component) throw new Error(`Function called outside component initialization`);
		return exports.current_component;
	}

	function beforeUpdate(fn) {
		get_current_component().$$.before_render.push(fn);
	}

	function onMount(fn) {
		get_current_component().$$.on_mount.push(fn);
	}

	function afterUpdate(fn) {
		get_current_component().$$.after_render.push(fn);
	}

	function onDestroy(fn) {
		get_current_component().$$.on_destroy.push(fn);
	}

	function createEventDispatcher() {
		const component = exports.current_component;

		return (type, detail) => {
			const callbacks = component.$$.callbacks[type];

			if (callbacks) {
				// TODO are there situations where events could be dispatched
				// in a server (non-DOM) environment?
				const event = custom_event(type, detail);
				callbacks.slice().forEach(fn => {
					fn.call(component, event);
				});
			}
		};
	}

	function setContext(key, context) {
		get_current_component().$$.context.set(key, context);
	}

	function getContext(key) {
		return get_current_component().$$.context.get(key);
	}

	// TODO figure out if we still want to support
	// shorthand events, or if we want to implement
	// a real bubbling mechanism
	function bubble(component, event) {
		const callbacks = component.$$.callbacks[event.type];

		if (callbacks) {
			callbacks.slice().forEach(fn => fn(event));
		}
	}

	const dirty_components = [];
	const intros = { enabled: false };

	let update_promise;
	const binding_callbacks = [];
	const render_callbacks = [];

	function schedule_update() {
		if (!update_promise) {
			update_promise = Promise.resolve();
			update_promise.then(flush);
		}
	}

	function add_render_callback(fn) {
		render_callbacks.push(fn);
	}

	function tick() {
		schedule_update();
		return update_promise;
	}

	function add_binding_callback(fn) {
		binding_callbacks.push(fn);
	}

	function flush() {
		const seen_callbacks = new Set();

		do {
			// first, call beforeUpdate functions
			// and update components
			while (dirty_components.length) {
				const component = dirty_components.shift();
				set_current_component(component);
				update(component.$$);
			}

			while (binding_callbacks.length) binding_callbacks.shift()();

			// then, once components are updated, call
			// afterUpdate functions. This may cause
			// subsequent updates...
			while (render_callbacks.length) {
				const callback = render_callbacks.pop();
				if (!seen_callbacks.has(callback)) {
					callback();

					// ...so guard against infinite loops
					seen_callbacks.add(callback);
				}
			}
		} while (dirty_components.length);

		update_promise = null;
	}

	function update($$) {
		if ($$.fragment) {
			$$.update($$.dirty);
			run_all($$.before_render);
			$$.fragment.p($$.dirty, $$.ctx);
			$$.dirty = null;

			$$.after_render.forEach(add_render_callback);
		}
	}

	let promise;

	function wait() {
		if (!promise) {
			promise = Promise.resolve();
			promise.then(() => {
				promise = null;
			});
		}

		return promise;
	}

	function dispatch(node, direction, kind) {
		node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
	}

	let outros;

	function group_outros() {
		outros = {
			remaining: 0,
			callbacks: []
		};
	}

	function check_outros() {
		if (!outros.remaining) {
			run_all(outros.callbacks);
		}
	}

	function on_outro(callback) {
		outros.callbacks.push(callback);
	}

	function create_in_transition(node, fn, params) {
		let config = fn(node, params);
		let running = false;
		let animation_name;
		let task;
		let uid = 0;

		function cleanup() {
			if (animation_name) delete_rule(node, animation_name);
		}

		function go() {
			const {
				delay = 0,
				duration = 300,
				easing = identity,
				tick: tick$$1 = noop,
				css
			} = config;

			if (css) animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
			tick$$1(0, 1);

			const start_time = window.performance.now() + delay;
			const end_time = start_time + duration;

			if (task) task.abort();
			running = true;

			task = loop(now => {
				if (running) {
					if (now >= end_time) {
						tick$$1(1, 0);
						cleanup();
						return running = false;
					}

					if (now >= start_time) {
						const t = easing((now - start_time) / duration);
						tick$$1(t, 1 - t);
					}
				}

				return running;
			});
		}

		let started = false;

		return {
			start() {
				if (started) return;

				delete_rule(node);

				if (typeof config === 'function') {
					config = config();
					wait().then(go);
				} else {
					go();
				}
			},

			invalidate() {
				started = false;
			},

			end() {
				if (running) {
					cleanup();
					running = false;
				}
			}
		};
	}

	function create_out_transition(node, fn, params) {
		let config = fn(node, params);
		let running = true;
		let animation_name;

		const group = outros;

		group.remaining += 1;

		function go() {
			const {
				delay = 0,
				duration = 300,
				easing = identity,
				tick: tick$$1 = noop,
				css
			} = config;

			if (css) animation_name = create_rule(node, 1, 0, duration, delay, easing, css);

			const start_time = window.performance.now() + delay;
			const end_time = start_time + duration;

			loop(now => {
				if (running) {
					if (now >= end_time) {
						tick$$1(0, 1);

						if (!--group.remaining) {
							// this will result in `end()` being called,
							// so we don't need to clean up here
							run_all(group.callbacks);
						}

						return false;
					}

					if (now >= start_time) {
						const t = easing((now - start_time) / duration);
						tick$$1(1 - t, t);
					}
				}

				return running;
			});
		}

		if (typeof config === 'function') {
			wait().then(() => {
				config = config();
				go();
			});
		} else {
			go();
		}

		return {
			end(reset) {
				if (reset && config.tick) {
					config.tick(1, 0);
				}

				if (running) {
					if (animation_name) delete_rule(node, animation_name);
					running = false;
				}
			}
		};
	}

	function create_bidirectional_transition(node, fn, params, intro) {
		let config = fn(node, params);

		let t = intro ? 0 : 1;

		let running_program = null;
		let pending_program = null;
		let animation_name = null;

		function clear_animation() {
			if (animation_name) delete_rule(node, animation_name);
		}

		function init(program, duration) {
			const d = program.b - t;
			duration *= Math.abs(d);

			return {
				a: t,
				b: program.b,
				d,
				duration,
				start: program.start,
				end: program.start + duration,
				group: program.group
			};
		}

		function go(b) {
			const {
				delay = 0,
				duration = 300,
				easing = identity,
				tick: tick$$1 = noop,
				css
			} = config;

			const program = {
				start: window.performance.now() + delay,
				b
			};

			if (!b) {
				program.group = outros;
				outros.remaining += 1;
			}

			if (running_program) {
				pending_program = program;
			} else {
				// if this is an intro, and there's a delay, we need to do
				// an initial tick and/or apply CSS animation immediately
				if (css) {
					clear_animation();
					animation_name = create_rule(node, t, b, duration, delay, easing, css);
				}

				if (b) tick$$1(0, 1);

				running_program = init(program, duration);
				add_render_callback(() => dispatch(node, b, 'start'));

				loop(now => {
					if (pending_program && now > pending_program.start) {
						running_program = init(pending_program, duration);
						pending_program = null;

						dispatch(node, running_program.b, 'start');

						if (css) {
							clear_animation();
							animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
						}
					}

					if (running_program) {
						if (now >= running_program.end) {
							tick$$1(t = running_program.b, 1 - t);
							dispatch(node, running_program.b, 'end');

							if (!pending_program) {
								// we're done
								if (running_program.b) {
									// intro — we can tidy up immediately
									clear_animation();
								} else {
									// outro — needs to be coordinated
									if (!--running_program.group.remaining) run_all(running_program.group.callbacks);
								}
							}

							running_program = null;
						}

						else if (now >= running_program.start) {
							const p = now - running_program.start;
							t = running_program.a + running_program.d * easing(p / running_program.duration);
							tick$$1(t, 1 - t);
						}
					}

					return !!(running_program || pending_program);
				});
			}
		}

		return {
			run(b) {
				if (typeof config === 'function') {
					wait().then(() => {
						config = config();
						go(b);
					});
				} else {
					go(b);
				}
			},

			end() {
				clear_animation();
				running_program = pending_program = null;
			}
		};
	}

	function handle_promise(promise, info) {
		const token = info.token = {};

		function update(type, index, key, value) {
			if (info.token !== token) return;

			info.resolved = key && { [key]: value };

			const child_ctx = assign(assign({}, info.ctx), info.resolved);
			const block = type && (info.current = type)(child_ctx);

			if (info.block) {
				if (info.blocks) {
					info.blocks.forEach((block, i) => {
						if (i !== index && block) {
							group_outros();
							on_outro(() => {
								block.d(1);
								info.blocks[i] = null;
							});
							block.o(1);
							check_outros();
						}
					});
				} else {
					info.block.d(1);
				}

				block.c();
				if (block.i) block.i(1);
				block.m(info.mount(), info.anchor);

				flush();
			}

			info.block = block;
			if (info.blocks) info.blocks[index] = block;
		}

		if (is_promise(promise)) {
			promise.then(value => {
				update(info.then, 1, info.value, value);
			}, error => {
				update(info.catch, 2, info.error, error);
			});

			// if we previously had a then/catch block, destroy it
			if (info.current !== info.pending) {
				update(info.pending, 0);
				return true;
			}
		} else {
			if (info.current !== info.then) {
				update(info.then, 1, info.value, promise);
				return true;
			}

			info.resolved = { [info.value]: promise };
		}
	}

	function destroy_block(block, lookup) {
		block.d(1);
		lookup[block.key] = null;
	}

	function outro_and_destroy_block(block, lookup) {
		on_outro(() => {
			destroy_block(block, lookup);
		});

		block.o(1);
	}

	function fix_and_outro_and_destroy_block(block, lookup) {
		block.f();
		outro_and_destroy_block(block, lookup);
	}

	function update_keyed_each(old_blocks, changed, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
		let o = old_blocks.length;
		let n = list.length;

		let i = o;
		const old_indexes = {};
		while (i--) old_indexes[old_blocks[i].key] = i;

		const new_blocks = [];
		const new_lookup = {};
		const deltas = {};

		i = n;
		while (i--) {
			const child_ctx = get_context(ctx, list, i);
			const key = get_key(child_ctx);
			let block = lookup[key];

			if (!block) {
				block = create_each_block(key, child_ctx);
				block.c();
			} else if (dynamic) {
				block.p(changed, child_ctx);
			}

			new_blocks[i] = new_lookup[key] = block;

			if (key in old_indexes) deltas[key] = Math.abs(i - old_indexes[key]);
		}

		const will_move = {};
		const did_move = {};

		function insert(block) {
			if (block.i) block.i(1);
			block.m(node, next);
			lookup[block.key] = block;
			next = block.first;
			n--;
		}

		while (o && n) {
			const new_block = new_blocks[n - 1];
			const old_block = old_blocks[o - 1];
			const new_key = new_block.key;
			const old_key = old_block.key;

			if (new_block === old_block) {
				// do nothing
				next = new_block.first;
				o--;
				n--;
			}

			else if (!new_lookup[old_key]) {
				// remove old block
				destroy(old_block, lookup);
				o--;
			}

			else if (!lookup[new_key] || will_move[new_key]) {
				insert(new_block);
			}

			else if (did_move[old_key]) {
				o--;

			} else if (deltas[new_key] > deltas[old_key]) {
				did_move[new_key] = true;
				insert(new_block);

			} else {
				will_move[old_key] = true;
				o--;
			}
		}

		while (o--) {
			const old_block = old_blocks[o];
			if (!new_lookup[old_block.key]) destroy(old_block, lookup);
		}

		while (n) insert(new_blocks[n - 1]);

		return new_blocks;
	}

	function measure(blocks) {
		const rects = {};
		let i = blocks.length;
		while (i--) rects[blocks[i].key] = blocks[i].node.getBoundingClientRect();
		return rects;
	}

	function get_spread_update(levels, updates) {
		const update = {};

		const to_null_out = {};
		const accounted_for = {};

		let i = levels.length;
		while (i--) {
			const o = levels[i];
			const n = updates[i];

			if (n) {
				for (const key in o) {
					if (!(key in n)) to_null_out[key] = 1;
				}

				for (const key in n) {
					if (!accounted_for[key]) {
						update[key] = n[key];
						accounted_for[key] = 1;
					}
				}

				levels[i] = n;
			} else {
				for (const key in o) {
					accounted_for[key] = 1;
				}
			}
		}

		for (const key in to_null_out) {
			if (!(key in update)) update[key] = undefined;
		}

		return update;
	}

	const invalid_attribute_name_character = /[\s'">/=\u{FDD0}-\u{FDEF}\u{FFFE}\u{FFFF}\u{1FFFE}\u{1FFFF}\u{2FFFE}\u{2FFFF}\u{3FFFE}\u{3FFFF}\u{4FFFE}\u{4FFFF}\u{5FFFE}\u{5FFFF}\u{6FFFE}\u{6FFFF}\u{7FFFE}\u{7FFFF}\u{8FFFE}\u{8FFFF}\u{9FFFE}\u{9FFFF}\u{AFFFE}\u{AFFFF}\u{BFFFE}\u{BFFFF}\u{CFFFE}\u{CFFFF}\u{DFFFE}\u{DFFFF}\u{EFFFE}\u{EFFFF}\u{FFFFE}\u{FFFFF}\u{10FFFE}\u{10FFFF}]/u;
	// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
	// https://infra.spec.whatwg.org/#noncharacter

	function spread(args) {
		const attributes = Object.assign({}, ...args);
		let str = '';

		Object.keys(attributes).forEach(name => {
			if (invalid_attribute_name_character.test(name)) return;

			const value = attributes[name];
			if (value === undefined) return;
			if (value === true) str += " " + name;

			const escaped = String(value)
				.replace(/"/g, '&#34;')
				.replace(/'/g, '&#39;');

			str += " " + name + "=" + JSON.stringify(escaped);
		});

		return str;
	}

	const escaped = {
		'"': '&quot;',
		"'": '&#39;',
		'&': '&amp;',
		'<': '&lt;',
		'>': '&gt;'
	};

	function escape(html) {
		return String(html).replace(/["'&<>]/g, match => escaped[match]);
	}

	function each(items, fn) {
		let str = '';
		for (let i = 0; i < items.length; i += 1) {
			str += fn(items[i], i);
		}
		return str;
	}

	const missing_component = {
		$$render: () => ''
	};

	function validate_component(component, name) {
		if (!component || !component.$$render) {
			if (name === 'svelte:component') name += ' this={...}';
			throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);
		}

		return component;
	}

	function debug(file, line, column, values) {
		console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console
		console.log(values); // eslint-disable-line no-console
		return '';
	}

	let on_destroy;

	function create_ssr_component(fn) {
		function $$render(result, props, bindings, slots) {
			const parent_component = exports.current_component;

			const $$ = {
				on_destroy,
				context: new Map(parent_component ? parent_component.$$.context : []),

				// these will be immediately discarded
				on_mount: [],
				before_render: [],
				after_render: [],
				callbacks: blank_object()
			};

			set_current_component({ $$ });

			const html = fn(result, props, bindings, slots);

			set_current_component(parent_component);
			return html;
		}

		return {
			render: (props = {}, options = {}) => {
				on_destroy = [];

				const result = { head: '', css: new Set() };
				const html = $$render(result, props, {}, options);

				run_all(on_destroy);

				return {
					html,
					css: {
						code: Array.from(result.css).map(css => css.code).join('\n'),
						map: null // TODO
					},
					head: result.head
				};
			},

			$$render
		};
	}

	function get_store_value(store) {
		let value;
		store.subscribe(_ => value = _)();
		return value;
	}

	function bind(component, name, callback) {
		if (component.$$.props.indexOf(name) === -1) return;
		component.$$.bound[name] = callback;
		callback(component.$$.ctx[name]);
	}

	function mount_component(component, target, anchor) {
		const { fragment, on_mount, on_destroy, after_render } = component.$$;

		fragment.m(target, anchor);

		// onMount happens after the initial afterUpdate. Because
		// afterUpdate callbacks happen in reverse order (inner first)
		// we schedule onMount callbacks before afterUpdate callbacks
		add_render_callback(() => {
			const new_on_destroy = on_mount.map(run).filter(is_function);
			if (on_destroy) {
				on_destroy.push(...new_on_destroy);
			} else {
				// Edge case - component was destroyed immediately,
				// most likely as a result of a binding initialising
				run_all(new_on_destroy);
			}
			component.$$.on_mount = [];
		});

		after_render.forEach(add_render_callback);
	}

	function destroy(component, detaching) {
		if (component.$$) {
			run_all(component.$$.on_destroy);
			component.$$.fragment.d(detaching);

			// TODO null out other refs, including component.$$ (but need to
			// preserve final state?)
			component.$$.on_destroy = component.$$.fragment = null;
			component.$$.ctx = {};
		}
	}

	function make_dirty(component, key) {
		if (!component.$$.dirty) {
			dirty_components.push(component);
			schedule_update();
			component.$$.dirty = {};
		}
		component.$$.dirty[key] = true;
	}

	function init(component, options, instance, create_fragment, not_equal$$1, prop_names) {
		const parent_component = exports.current_component;
		set_current_component(component);

		const props = options.props || {};

		const $$ = component.$$ = {
			fragment: null,
			ctx: null,

			// state
			props: prop_names,
			update: noop,
			not_equal: not_equal$$1,
			bound: blank_object(),

			// lifecycle
			on_mount: [],
			on_destroy: [],
			before_render: [],
			after_render: [],
			context: new Map(parent_component ? parent_component.$$.context : []),

			// everything else
			callbacks: blank_object(),
			dirty: null
		};

		let ready = false;

		$$.ctx = instance
			? instance(component, props, (key, value) => {
				if ($$.bound[key]) $$.bound[key](value);

				if ($$.ctx) {
					const changed = not_equal$$1(value, $$.ctx[key]);
					if (ready && changed) {
						make_dirty(component, key);
					}

					$$.ctx[key] = value;
					return changed;
				}
			})
			: props;

		$$.update();
		ready = true;
		run_all($$.before_render);
		$$.fragment = create_fragment($$.ctx);

		if (options.target) {
			if (options.hydrate) {
				$$.fragment.l(children(options.target));
			} else {
				$$.fragment.c();
			}

			if (options.intro && component.$$.fragment.i) component.$$.fragment.i();
			mount_component(component, options.target, options.anchor);
			flush();
		}

		set_current_component(parent_component);
	}
	if (typeof HTMLElement !== 'undefined') {
		exports.SvelteElement = class extends HTMLElement {
			constructor() {
				super();
				this.attachShadow({ mode: 'open' });
			}

			connectedCallback() {
				for (const key in this.$$.slotted) {
					this.appendChild(this.$$.slotted[key]);
				}
			}

			attributeChangedCallback(attr$$1, oldValue, newValue) {
				this[attr$$1] = newValue;
			}

			$destroy() {
				destroy(this, true);
				this.$destroy = noop;
			}

			$on(type, callback) {
				// TODO should this delegate to addEventListener?
				const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
				callbacks.push(callback);

				return () => {
					const index = callbacks.indexOf(callback);
					if (index !== -1) callbacks.splice(index, 1);
				};
			}

			$set() {
				// overridden by instance, if it has props
			}
		};
	}

	class SvelteComponent {
		$destroy() {
			destroy(this, true);
			this.$destroy = noop;
		}

		$on(type, callback) {
			const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
			callbacks.push(callback);

			return () => {
				const index = callbacks.indexOf(callback);
				if (index !== -1) callbacks.splice(index, 1);
			};
		}

		$set() {
			// overridden by instance, if it has props
		}
	}

	class SvelteComponentDev extends SvelteComponent {
		constructor(options) {
			if (!options || (!options.target && !options.$$inline)) {
				throw new Error(`'target' is a required option`);
			}

			super();
		}

		$destroy() {
			super.$destroy();
			this.$destroy = () => {
				console.warn(`Component was already destroyed`); // eslint-disable-line no-console
			};
		}
	}

	exports.create_animation = create_animation;
	exports.fix_position = fix_position;
	exports.handle_promise = handle_promise;
	exports.append = append;
	exports.insert = insert;
	exports.detach = detach;
	exports.detach_between = detach_between;
	exports.detach_before = detach_before;
	exports.detach_after = detach_after;
	exports.destroy_each = destroy_each;
	exports.element = element;
	exports.svg_element = svg_element;
	exports.text = text;
	exports.space = space;
	exports.empty = empty;
	exports.listen = listen;
	exports.prevent_default = prevent_default;
	exports.stop_propagation = stop_propagation;
	exports.attr = attr;
	exports.set_attributes = set_attributes;
	exports.set_custom_element_data = set_custom_element_data;
	exports.xlink_attr = xlink_attr;
	exports.get_binding_group_value = get_binding_group_value;
	exports.to_number = to_number;
	exports.time_ranges_to_array = time_ranges_to_array;
	exports.children = children;
	exports.claim_element = claim_element;
	exports.claim_text = claim_text;
	exports.set_data = set_data;
	exports.set_input_type = set_input_type;
	exports.set_style = set_style;
	exports.select_option = select_option;
	exports.select_options = select_options;
	exports.select_value = select_value;
	exports.select_multiple_value = select_multiple_value;
	exports.add_resize_listener = add_resize_listener;
	exports.toggle_class = toggle_class;
	exports.custom_event = custom_event;
	exports.destroy_block = destroy_block;
	exports.outro_and_destroy_block = outro_and_destroy_block;
	exports.fix_and_outro_and_destroy_block = fix_and_outro_and_destroy_block;
	exports.update_keyed_each = update_keyed_each;
	exports.measure = measure;
	exports.set_current_component = set_current_component;
	exports.beforeUpdate = beforeUpdate;
	exports.onMount = onMount;
	exports.afterUpdate = afterUpdate;
	exports.onDestroy = onDestroy;
	exports.createEventDispatcher = createEventDispatcher;
	exports.setContext = setContext;
	exports.getContext = getContext;
	exports.bubble = bubble;
	exports.clear_loops = clear_loops;
	exports.loop = loop;
	exports.dirty_components = dirty_components;
	exports.intros = intros;
	exports.schedule_update = schedule_update;
	exports.add_render_callback = add_render_callback;
	exports.tick = tick;
	exports.add_binding_callback = add_binding_callback;
	exports.flush = flush;
	exports.get_spread_update = get_spread_update;
	exports.invalid_attribute_name_character = invalid_attribute_name_character;
	exports.spread = spread;
	exports.escaped = escaped;
	exports.escape = escape;
	exports.each = each;
	exports.missing_component = missing_component;
	exports.validate_component = validate_component;
	exports.debug = debug;
	exports.create_ssr_component = create_ssr_component;
	exports.get_store_value = get_store_value;
	exports.group_outros = group_outros;
	exports.check_outros = check_outros;
	exports.on_outro = on_outro;
	exports.create_in_transition = create_in_transition;
	exports.create_out_transition = create_out_transition;
	exports.create_bidirectional_transition = create_bidirectional_transition;
	exports.noop = noop;
	exports.identity = identity;
	exports.assign = assign;
	exports.is_promise = is_promise;
	exports.add_location = add_location;
	exports.run = run;
	exports.blank_object = blank_object;
	exports.run_all = run_all;
	exports.is_function = is_function;
	exports.safe_not_equal = safe_not_equal;
	exports.not_equal = not_equal;
	exports.validate_store = validate_store;
	exports.subscribe = subscribe;
	exports.create_slot = create_slot;
	exports.get_slot_context = get_slot_context;
	exports.get_slot_changes = get_slot_changes;
	exports.exclude_internal_props = exclude_internal_props;
	exports.bind = bind;
	exports.mount_component = mount_component;
	exports.init = init;
	exports.SvelteComponent = SvelteComponent;
	exports.SvelteComponentDev = SvelteComponentDev;
	});

	unwrapExports(internal);
	var internal_1 = internal.current_component;
	var internal_2 = internal.SvelteElement;
	var internal_3 = internal.create_animation;
	var internal_4 = internal.fix_position;
	var internal_5 = internal.handle_promise;
	var internal_6 = internal.append;
	var internal_7 = internal.insert;
	var internal_8 = internal.detach;
	var internal_9 = internal.detach_between;
	var internal_10 = internal.detach_before;
	var internal_11 = internal.detach_after;
	var internal_12 = internal.destroy_each;
	var internal_13 = internal.element;
	var internal_14 = internal.svg_element;
	var internal_15 = internal.text;
	var internal_16 = internal.space;
	var internal_17 = internal.empty;
	var internal_18 = internal.listen;
	var internal_19 = internal.prevent_default;
	var internal_20 = internal.stop_propagation;
	var internal_21 = internal.attr;
	var internal_22 = internal.set_attributes;
	var internal_23 = internal.set_custom_element_data;
	var internal_24 = internal.xlink_attr;
	var internal_25 = internal.get_binding_group_value;
	var internal_26 = internal.to_number;
	var internal_27 = internal.time_ranges_to_array;
	var internal_28 = internal.children;
	var internal_29 = internal.claim_element;
	var internal_30 = internal.claim_text;
	var internal_31 = internal.set_data;
	var internal_32 = internal.set_input_type;
	var internal_33 = internal.set_style;
	var internal_34 = internal.select_option;
	var internal_35 = internal.select_options;
	var internal_36 = internal.select_value;
	var internal_37 = internal.select_multiple_value;
	var internal_38 = internal.add_resize_listener;
	var internal_39 = internal.toggle_class;
	var internal_40 = internal.custom_event;
	var internal_41 = internal.destroy_block;
	var internal_42 = internal.outro_and_destroy_block;
	var internal_43 = internal.fix_and_outro_and_destroy_block;
	var internal_44 = internal.update_keyed_each;
	var internal_45 = internal.measure;
	var internal_46 = internal.set_current_component;
	var internal_47 = internal.beforeUpdate;
	var internal_48 = internal.onMount;
	var internal_49 = internal.afterUpdate;
	var internal_50 = internal.onDestroy;
	var internal_51 = internal.createEventDispatcher;
	var internal_52 = internal.setContext;
	var internal_53 = internal.getContext;
	var internal_54 = internal.bubble;
	var internal_55 = internal.clear_loops;
	var internal_56 = internal.loop;
	var internal_57 = internal.dirty_components;
	var internal_58 = internal.intros;
	var internal_59 = internal.schedule_update;
	var internal_60 = internal.add_render_callback;
	var internal_61 = internal.tick;
	var internal_62 = internal.add_binding_callback;
	var internal_63 = internal.flush;
	var internal_64 = internal.get_spread_update;
	var internal_65 = internal.invalid_attribute_name_character;
	var internal_66 = internal.spread;
	var internal_67 = internal.escaped;
	var internal_68 = internal.escape;
	var internal_69 = internal.each;
	var internal_70 = internal.missing_component;
	var internal_71 = internal.validate_component;
	var internal_72 = internal.debug;
	var internal_73 = internal.create_ssr_component;
	var internal_74 = internal.get_store_value;
	var internal_75 = internal.group_outros;
	var internal_76 = internal.check_outros;
	var internal_77 = internal.on_outro;
	var internal_78 = internal.create_in_transition;
	var internal_79 = internal.create_out_transition;
	var internal_80 = internal.create_bidirectional_transition;
	var internal_81 = internal.noop;
	var internal_82 = internal.identity;
	var internal_83 = internal.assign;
	var internal_84 = internal.is_promise;
	var internal_85 = internal.add_location;
	var internal_86 = internal.run;
	var internal_87 = internal.blank_object;
	var internal_88 = internal.run_all;
	var internal_89 = internal.is_function;
	var internal_90 = internal.safe_not_equal;
	var internal_91 = internal.not_equal;
	var internal_92 = internal.validate_store;
	var internal_93 = internal.subscribe;
	var internal_94 = internal.create_slot;
	var internal_95 = internal.get_slot_context;
	var internal_96 = internal.get_slot_changes;
	var internal_97 = internal.exclude_internal_props;
	var internal_98 = internal.bind;
	var internal_99 = internal.mount_component;
	var internal_100 = internal.init;
	var internal_101 = internal.SvelteComponent;
	var internal_102 = internal.SvelteComponentDev;

	var lib = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var prefixMap = {
	  pointerdown: 'MSPointerDown',
	  pointerup: 'MSPointerUp',
	  pointercancel: 'MSPointerCancel',
	  pointermove: 'MSPointerMove',
	  pointerover: 'MSPointerOver',
	  pointerout: 'MSPointerOut',
	  pointerenter: 'MSPointerEnter',
	  pointerleave: 'MSPointerLeave',
	  gotpointercapture: 'MSGotPointerCapture',
	  lostpointercapture: 'MSLostPointerCapture',
	  maxTouchPoints: 'msMaxTouchPoints'
	};

	/*
	 * detectPointerEvents object structure
	 * const detectPointerEvents = {
	 *   hasApi: boolean,
	 *   requiresPrefix: boolean,
	 *   hasTouch: boolean,
	 *   maxTouchPoints: number,
	 *   update() {...},
	 *   prefix(value) {return value, value will only have prefix if requiresPrefix === true},
	 * }
	 */
	var detectPointerEvents = {
	  update: function update() {
	    if (typeof window !== 'undefined') {
	      // reference for detection https://msdn.microsoft.com/en-us/library/dn433244(v=vs.85).aspx
	      if ('PointerEvent' in window) {
	        detectPointerEvents.hasApi = true;
	        detectPointerEvents.requiresPrefix = false;

	        // reference for detection https://msdn.microsoft.com/library/hh673557(v=vs.85).aspx
	      } else if (window.navigator && 'msPointerEnabled' in window.navigator) {
	        detectPointerEvents.hasApi = true;
	        detectPointerEvents.requiresPrefix = true;
	      } else {
	        detectPointerEvents.hasApi = false;
	        detectPointerEvents.requiresPrefix = undefined;
	      }
	      detectPointerEvents.maxTouchPoints = detectPointerEvents.hasApi && window.navigator && window.navigator[detectPointerEvents.prefix('maxTouchPoints')] || undefined;
	      detectPointerEvents.hasTouch = detectPointerEvents.hasApi ? detectPointerEvents.maxTouchPoints > 0 : undefined;
	    }
	  },
	  prefix: function prefix(value) {
	    return detectPointerEvents.requiresPrefix && prefixMap[value] || value;
	  }
	};

	detectPointerEvents.update();
	exports.default = detectPointerEvents;
	});

	var detectPointerEvents = unwrapExports(lib);

	function iterationCopy(src) {
	    let target = {};
	    for (let prop in src) {
	        target[prop] = src[prop];
	    }
	    return target;
	}
	function updateScale(transform, s, x, y) {
	    const minScale = transform.getMinScale();
	    const scale = transform.getScale();
	    if (s < minScale)
	        s = minScale;
	    let offsetX = transform.getOffsetX();
	    let offsetY = transform.getOffsetY();
	    offsetX = s * (offsetX + x) / scale - x;
	    offsetY = s * (offsetY + y) / scale - y;
	    transform.setOffsetX(offsetX);
	    transform.setOffsetY(offsetY);
	    transform.setScale(s);
	}
	function simpleDragZoom(e, scaleOrigin, transform) {
	    if (e.shiftKey) {
	        if (!scaleOrigin)
	            scaleOrigin = { x: e.offsetX, y: e.offsetY, s: transform.getScale() };
	        updateScale(transform, scaleOrigin.s + (scaleOrigin.y - e.offsetY) / 50, scaleOrigin.x, scaleOrigin.y);
	    }
	    else {
	        scaleOrigin = null;
	        let offsetX = transform.getOffsetX();
	        let offsetY = transform.getOffsetY();
	        offsetX -= e.movementX;
	        offsetY -= e.movementY;
	        transform.setOffsetX(offsetX);
	        transform.setOffsetY(offsetY);
	    }
	    return scaleOrigin;
	}
	function withPointers(node, transform) {
	    function rescaleWithWheel(e) {
	        e.preventDefault();
	        e.cancelBubble = true;
	        const delta = Math.sign(e.deltaY);
	        updateScale(transform, transform.getScale() - delta / 10, e.offsetX, e.offsetY);
	    }
	    const pointers = [];
	    function storeEvent(ev) {
	        for (var i = 0; i < pointers.length; i++) {
	            if (pointers[i].pointerId === ev.pointerId) {
	                const ev2 = iterationCopy(ev);
	                pointers[i] = ev2;
	                break;
	            }
	        }
	        if (i === pointers.length)
	            pointers.push(ev);
	    }
	    function removeEvent(ev) {
	        for (var i = 0; i < pointers.length; i++) {
	            if (pointers[i].pointerId === ev.pointerId) {
	                pointers.splice(i, 1);
	                break;
	            }
	        }
	    }
	    let scaleOrigin = null;
	    function startDrag(e) {
	        node.setPointerCapture(e.pointerId);
	        if (!transform.getDragging()) {
	            node.addEventListener(detectPointerEvents.prefix('pointermove'), drag, true);
	            transform.setDragging(true);
	        }
	        e.preventDefault();
	        e.cancelBubble = true;
	        storeEvent(e);
	    }
	    function drag(e) {
	        if (pointers.length === 1) {
	            scaleOrigin = simpleDragZoom(e, scaleOrigin, transform);
	        }
	        else if (pointers.length === 2) {
	            const x0 = pointers[0].offsetX;
	            const y0 = pointers[0].offsetY;
	            const x1 = pointers[1].offsetX;
	            const y1 = pointers[1].offsetY;
	            const x2 = e.offsetX;
	            const y2 = e.offsetY;
	            const dx = x0 - x1;
	            const dy = y0 - y1;
	            const l1 = Math.sqrt(dx * dx + dy * dy);
	            let dx1, dy1;
	            if (e.pointerId === pointers[0].pointerId) {
	                dx1 = x2 - x1;
	                dy1 = y2 - y1;
	            }
	            else {
	                dx1 = x2 - x0;
	                dy1 = y2 - y0;
	            }
	            var l2 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
	            updateScale(transform, transform.getScale() * l2 / l1, x2, y2);
	        }
	        e.preventDefault();
	        e.cancelBubble = true;
	        storeEvent(e);
	    }
	    function stopDrag(e) {
	        e.preventDefault();
	        e.cancelBubble = true;
	        removeEvent(e);
	        node.releasePointerCapture(e.pointerId);
	        if (pointers.length === 0) {
	            transform.setDragging(false);
	            node.removeEventListener(detectPointerEvents.prefix('pointermove'), drag, true);
	            scaleOrigin = null;
	        }
	    }
	    node.addEventListener(detectPointerEvents.prefix('pointerdown'), startDrag, true);
	    node.addEventListener(detectPointerEvents.prefix('pointerup'), stopDrag, true);
	    node.addEventListener('wheel', rescaleWithWheel, true);
	    return () => {
	        node.removeEventListener(detectPointerEvents.prefix('pointerdown'), startDrag, true);
	        node.removeEventListener(detectPointerEvents.prefix('pointerup'), stopDrag, true);
	        node.removeEventListener('wheel', rescaleWithWheel, true);
	    };
	}
	function withMouse(node, transform) {
	    function rescaleWithWheel(e) {
	        e.preventDefault();
	        e.cancelBubble = true;
	        const delta = Math.sign(e.deltaY);
	        updateScale(transform, transform.getScale() - delta / 10, e.offsetX, e.offsetY);
	    }
	    let scaleOrigin = null;
	    function startDrag(e) {
	        if (typeof node.setCapture === 'function')
	            node.setCapture();
	        if (!transform.getDragging()) {
	            node.addEventListener('mousemove', drag, true);
	            transform.setDragging(true);
	        }
	        e.preventDefault();
	        e.cancelBubble = true;
	    }
	    function drag(e) {
	        scaleOrigin = simpleDragZoom(e, scaleOrigin, transform);
	        e.preventDefault();
	        e.cancelBubble = true;
	    }
	    function stopDrag(e) {
	        e.preventDefault();
	        e.cancelBubble = true;
	        if (typeof node.releaseCapture === 'function')
	            node.releaseCapture();
	        transform.setDragging(false);
	        node.removeEventListener('mousemove', drag, true);
	        scaleOrigin = null;
	    }
	    node.addEventListener('mousedown', startDrag, true);
	    node.addEventListener('mouseup', stopDrag, true);
	    node.addEventListener('wheel', rescaleWithWheel, true);
	    return () => {
	        node.removeEventListener('mousedown', startDrag, true);
	        node.removeEventListener('mouseup', stopDrag, true);
	        node.removeEventListener('wheel', rescaleWithWheel, true);
	    };
	}
	const usePointerEvents = process.browser && !!detectPointerEvents.maxTouchPoints;
	const panHandler = usePointerEvents ? withPointers : withMouse;

	var I__Work_repos_svelteImageEncoder_node_modules_svelte = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, '__esModule', { value: true });





	exports.onMount = internal.onMount;
	exports.onDestroy = internal.onDestroy;
	exports.beforeUpdate = internal.beforeUpdate;
	exports.afterUpdate = internal.afterUpdate;
	exports.setContext = internal.setContext;
	exports.getContext = internal.getContext;
	exports.tick = internal.tick;
	exports.createEventDispatcher = internal.createEventDispatcher;
	});

	unwrapExports(I__Work_repos_svelteImageEncoder_node_modules_svelte);
	var I__Work_repos_svelteImageEncoder_node_modules_svelte_1 = I__Work_repos_svelteImageEncoder_node_modules_svelte.onMount;
	var I__Work_repos_svelteImageEncoder_node_modules_svelte_2 = I__Work_repos_svelteImageEncoder_node_modules_svelte.onDestroy;
	var I__Work_repos_svelteImageEncoder_node_modules_svelte_3 = I__Work_repos_svelteImageEncoder_node_modules_svelte.beforeUpdate;
	var I__Work_repos_svelteImageEncoder_node_modules_svelte_4 = I__Work_repos_svelteImageEncoder_node_modules_svelte.afterUpdate;
	var I__Work_repos_svelteImageEncoder_node_modules_svelte_5 = I__Work_repos_svelteImageEncoder_node_modules_svelte.setContext;
	var I__Work_repos_svelteImageEncoder_node_modules_svelte_6 = I__Work_repos_svelteImageEncoder_node_modules_svelte.getContext;
	var I__Work_repos_svelteImageEncoder_node_modules_svelte_7 = I__Work_repos_svelteImageEncoder_node_modules_svelte.tick;
	var I__Work_repos_svelteImageEncoder_node_modules_svelte_8 = I__Work_repos_svelteImageEncoder_node_modules_svelte.createEventDispatcher;

	/* src\ImgEncoder.svelte generated by Svelte v3.0.0-beta.23 */

	function add_css() {
		var style = internal_13("style");
		style.id = 'svelte-11j8b7d-style';
		style.textContent = "canvas.svelte-11j8b7d{touch-action:none;position:relative}";
		internal_6(document.head, style);
	}

	function create_fragment(ctx) {
		var canvas_1, panHandler_action;

		return {
			c() {
				canvas_1 = internal_13("canvas");
				canvas_1.width = ctx.width;
				canvas_1.height = ctx.height;
				canvas_1.className = "" + ctx.classes + " svelte-11j8b7d";
			},

			m(target, anchor) {
				internal_7(target, canvas_1, anchor);
				internal_62(() => ctx.canvas_1_binding(canvas_1, null));
				panHandler_action = panHandler.call(null, canvas_1, ctx.transform) || {};
			},

			p(changed, ctx) {
				if (changed.items) {
					ctx.canvas_1_binding(null, canvas_1);
					ctx.canvas_1_binding(canvas_1, null);
				}

				if (changed.width) {
					canvas_1.width = ctx.width;
				}

				if (changed.height) {
					canvas_1.height = ctx.height;
				}

				if (changed.classes) {
					canvas_1.className = "" + ctx.classes + " svelte-11j8b7d";
				}
			},

			i: internal_81,
			o: internal_81,

			d(detaching) {
				if (detaching) {
					internal_8(canvas_1);
				}

				ctx.canvas_1_binding(null, canvas_1);
				if (panHandler_action && typeof panHandler_action.destroy === 'function') panHandler_action.destroy();
			}
		};
	}

	function instance($$self, $$props, $$invalidate) {
		
		let { src = '', url = '', quality = 0.5, width = 256, height = 256, realTime = false, crossOrigin = false, classes = '' } = $$props;
		let canvas;
		let img;
		let ctx;
		let offsetX = 0;
		let offsetY = 0;
		let scale = 1;
		let minScale = 1;
		let dragging = false;
		// not a POJO because getters/setters are instrumentable by Svelte
		// and `transform` is updated by imported functions
		let transform = {
			getMinScale() {
				return minScale;
			},
			getScale() {
				return scale;
			},
			setScale(s) {
				scale = s; $$invalidate('scale', scale);
			},
			getOffsetX() {
				return offsetX;
			},
			getOffsetY() {
				return offsetY;
			},
			setOffsetX(ox) {
				offsetX = ox; $$invalidate('offsetX', offsetX);
			},
			setOffsetY(oy) {
				offsetY = oy; $$invalidate('offsetY', offsetY);
			},
			setDragging(d) {
				if (!realTime && d === false)
					{ url = canvas.toDataURL('image/jpeg', quality); $$invalidate('url', url); }
				dragging = d; $$invalidate('dragging', dragging);
			},
			getDragging() {
				return dragging;
			}
		};
		function redraw() {
			if (!img || !ctx)
				return;
			if (offsetX < 0)
				{ offsetX = 0; $$invalidate('offsetX', offsetX); }
			if (offsetY < 0)
				{ offsetY = 0; $$invalidate('offsetY', offsetY); }
			let limit = img.width * scale - width;
			if (offsetX > limit)
				{ offsetX = limit; $$invalidate('offsetX', offsetX); }
			limit = img.height * scale - height;
			if (offsetY > limit)
				{ offsetY = limit; $$invalidate('offsetY', offsetY); }
			ctx.resetTransform();
			ctx.clearRect(0, 0, width, height);
			ctx.translate(-offsetX, -offsetY);
			ctx.scale(scale, scale);
			ctx.drawImage(img, 0, 0);
			if (realTime || !dragging)
				{ url = canvas.toDataURL('image/jpeg', quality); $$invalidate('url', url); }
		}
		I__Work_repos_svelteImageEncoder_node_modules_svelte_1(() => {
			ctx = canvas.getContext('2d'); $$invalidate('ctx', ctx);
			img = new Image(); $$invalidate('img', img);
			img.onload = function () {
				offsetX = 0; $$invalidate('offsetX', offsetX);
				offsetY = 0; $$invalidate('offsetY', offsetY);
				scale = minScale = Math.max(width / img.width, height / img.height); $$invalidate('minScale', minScale); $$invalidate('scale', scale);
			}; $$invalidate('img', img);
		});

		function canvas_1_binding($$node, check) {
			canvas = $$node;
			$$invalidate('canvas', canvas);
		}

		$$self.$set = $$props => {
			if ('src' in $$props) $$invalidate('src', src = $$props.src);
			if ('url' in $$props) $$invalidate('url', url = $$props.url);
			if ('quality' in $$props) $$invalidate('quality', quality = $$props.quality);
			if ('width' in $$props) $$invalidate('width', width = $$props.width);
			if ('height' in $$props) $$invalidate('height', height = $$props.height);
			if ('realTime' in $$props) $$invalidate('realTime', realTime = $$props.realTime);
			if ('crossOrigin' in $$props) $$invalidate('crossOrigin', crossOrigin = $$props.crossOrigin);
			if ('classes' in $$props) $$invalidate('classes', classes = $$props.classes);
		};

		$$self.$$.update = ($$dirty = { img: 1, crossOrigin: 1, src: 1, quality: 1, width: 1, height: 1, offsetX: 1, offsetY: 1, scale: 1 }) => {
			if ($$dirty.img || $$dirty.crossOrigin) {
				img && (img.crossOrigin = crossOrigin ? 'anonymous' : null); $$invalidate('img', img);
			}
			if ($$dirty.img || $$dirty.src) {
				img && (img.src = src); $$invalidate('img', img);
			}
			if ($$dirty.quality || $$dirty.width || $$dirty.height || $$dirty.offsetX || $$dirty.offsetY || $$dirty.scale) {
				redraw();
			}
		};

		return {
			src,
			url,
			quality,
			width,
			height,
			realTime,
			crossOrigin,
			classes,
			canvas,
			transform,
			canvas_1_binding
		};
	}

	class ImgEncoder extends internal_101 {
		constructor(options) {
			super();
			if (!document.getElementById("svelte-11j8b7d-style")) add_css();
			internal_100(this, options, instance, create_fragment, internal_90, ["src", "url", "quality", "width", "height", "realTime", "crossOrigin", "classes"]);
		}
	}

	return ImgEncoder;

}));
