import "./chunk-6A2TAOKG.js";
import {
  SvelteComponentDev,
  __commonJS,
  __toESM,
  action_destroyer,
  add_location,
  append_styles,
  attr_dev,
  binding_callbacks,
  detach_dev,
  dispatch_dev,
  element,
  init,
  insert_dev,
  noop,
  null_to_empty,
  onMount,
  safe_not_equal,
  validate_slots
} from "./chunk-VU5KYWUG.js";

// node_modules/detect-pointer-events/lib/index.js
var require_lib = __commonJS({
  "node_modules/detect-pointer-events/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var prefixMap = {
      pointerdown: "MSPointerDown",
      pointerup: "MSPointerUp",
      pointercancel: "MSPointerCancel",
      pointermove: "MSPointerMove",
      pointerover: "MSPointerOver",
      pointerout: "MSPointerOut",
      pointerenter: "MSPointerEnter",
      pointerleave: "MSPointerLeave",
      gotpointercapture: "MSGotPointerCapture",
      lostpointercapture: "MSLostPointerCapture",
      maxTouchPoints: "msMaxTouchPoints"
    };
    var detectPointerEvents2 = {
      update: function update() {
        if (typeof window !== "undefined") {
          if ("PointerEvent" in window) {
            detectPointerEvents2.hasApi = true;
            detectPointerEvents2.requiresPrefix = false;
          } else if (window.navigator && "msPointerEnabled" in window.navigator) {
            detectPointerEvents2.hasApi = true;
            detectPointerEvents2.requiresPrefix = true;
          } else {
            detectPointerEvents2.hasApi = false;
            detectPointerEvents2.requiresPrefix = void 0;
          }
          detectPointerEvents2.maxTouchPoints = detectPointerEvents2.hasApi && window.navigator && window.navigator[detectPointerEvents2.prefix("maxTouchPoints")] || void 0;
          detectPointerEvents2.hasTouch = detectPointerEvents2.hasApi ? detectPointerEvents2.maxTouchPoints > 0 : void 0;
        }
      },
      prefix: function prefix(value) {
        return detectPointerEvents2.requiresPrefix && prefixMap[value] || value;
      }
    };
    detectPointerEvents2.update();
    exports.default = detectPointerEvents2;
  }
});

// node_modules/svelte-image-encoder/src/pan-zoom.ts
var import_detect_pointer_events = __toESM(require_lib());
function iterationCopy(src) {
  let target = {};
  for (let prop in src) {
    target[prop] = src[prop];
  }
  return target;
}
function updateScale(transform, s, x, y) {
  const minScale = transform.getMinScale();
  const scale = transform.getScale();
  if (s < minScale)
    s = minScale;
  let offsetX = transform.getOffsetX();
  let offsetY = transform.getOffsetY();
  offsetX = s * (offsetX + x) / scale - x;
  offsetY = s * (offsetY + y) / scale - y;
  transform.setOffsetX(offsetX);
  transform.setOffsetY(offsetY);
  transform.setScale(s);
}
function simpleDragZoom(e, scaleOrigin, transform) {
  if (e.shiftKey) {
    if (!scaleOrigin)
      scaleOrigin = { x: e.offsetX, y: e.offsetY, s: transform.getScale() };
    updateScale(transform, scaleOrigin.s + (scaleOrigin.y - e.offsetY) / 50, scaleOrigin.x, scaleOrigin.y);
  } else {
    scaleOrigin = null;
    let offsetX = transform.getOffsetX();
    let offsetY = transform.getOffsetY();
    offsetX -= e.movementX;
    offsetY -= e.movementY;
    transform.setOffsetX(offsetX);
    transform.setOffsetY(offsetY);
  }
  return scaleOrigin;
}
function withPointers(node, transform) {
  function rescaleWithWheel(e) {
    e.preventDefault();
    e.cancelBubble = true;
    const delta = Math.sign(e.deltaY);
    updateScale(transform, transform.getScale() - delta / 10, e.offsetX, e.offsetY);
  }
  const pointers = [];
  function storeEvent(ev) {
    for (var i = 0; i < pointers.length; i++) {
      if (pointers[i].pointerId === ev.pointerId) {
        const ev2 = iterationCopy(ev);
        pointers[i] = ev2;
        break;
      }
    }
    if (i === pointers.length)
      pointers.push(ev);
  }
  function removeEvent(ev) {
    for (var i = 0; i < pointers.length; i++) {
      if (pointers[i].pointerId === ev.pointerId) {
        pointers.splice(i, 1);
        break;
      }
    }
  }
  let scaleOrigin = null;
  function startDrag(e) {
    node.setPointerCapture(e.pointerId);
    if (!transform.getDragging()) {
      node.addEventListener(import_detect_pointer_events.default.prefix("pointermove"), drag, true);
      transform.setDragging(true);
    }
    e.preventDefault();
    e.cancelBubble = true;
    storeEvent(e);
  }
  function drag(e) {
    if (pointers.length === 1) {
      scaleOrigin = simpleDragZoom(e, scaleOrigin, transform);
    } else if (pointers.length === 2) {
      const x0 = pointers[0].offsetX;
      const y0 = pointers[0].offsetY;
      const x1 = pointers[1].offsetX;
      const y1 = pointers[1].offsetY;
      const x2 = e.offsetX;
      const y2 = e.offsetY;
      const dx = x0 - x1;
      const dy = y0 - y1;
      const l1 = Math.sqrt(dx * dx + dy * dy);
      let dx1, dy1;
      if (e.pointerId === pointers[0].pointerId) {
        dx1 = x2 - x1;
        dy1 = y2 - y1;
      } else {
        dx1 = x2 - x0;
        dy1 = y2 - y0;
      }
      var l2 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
      updateScale(transform, transform.getScale() * l2 / l1, x2, y2);
    }
    e.preventDefault();
    e.cancelBubble = true;
    storeEvent(e);
  }
  function stopDrag(e) {
    e.preventDefault();
    e.cancelBubble = true;
    removeEvent(e);
    node.releasePointerCapture(e.pointerId);
    if (pointers.length === 0) {
      transform.setDragging(false);
      node.removeEventListener(import_detect_pointer_events.default.prefix("pointermove"), drag, true);
      scaleOrigin = null;
    }
  }
  node.addEventListener(import_detect_pointer_events.default.prefix("pointerdown"), startDrag, true);
  node.addEventListener(import_detect_pointer_events.default.prefix("pointerup"), stopDrag, true);
  node.addEventListener("wheel", rescaleWithWheel, true);
  return () => {
    node.removeEventListener(import_detect_pointer_events.default.prefix("pointerdown"), startDrag, true);
    node.removeEventListener(import_detect_pointer_events.default.prefix("pointerup"), stopDrag, true);
    node.removeEventListener("wheel", rescaleWithWheel, true);
  };
}
function withMouse(node, transform) {
  function rescaleWithWheel(e) {
    e.preventDefault();
    e.cancelBubble = true;
    const delta = Math.sign(e.deltaY);
    updateScale(transform, transform.getScale() - delta / 10, e.offsetX, e.offsetY);
  }
  let scaleOrigin = null;
  function startDrag(e) {
    if (typeof node.setCapture === "function")
      node.setCapture();
    if (!transform.getDragging()) {
      node.addEventListener("mousemove", drag, true);
      transform.setDragging(true);
    }
    e.preventDefault();
    e.cancelBubble = true;
  }
  function drag(e) {
    scaleOrigin = simpleDragZoom(e, scaleOrigin, transform);
    e.preventDefault();
    e.cancelBubble = true;
  }
  function stopDrag(e) {
    e.preventDefault();
    e.cancelBubble = true;
    if (typeof node.releaseCapture === "function")
      node.releaseCapture();
    transform.setDragging(false);
    node.removeEventListener("mousemove", drag, true);
    scaleOrigin = null;
  }
  node.addEventListener("mousedown", startDrag, true);
  node.addEventListener("mouseup", stopDrag, true);
  node.addEventListener("wheel", rescaleWithWheel, true);
  return () => {
    node.removeEventListener("mousedown", startDrag, true);
    node.removeEventListener("mouseup", stopDrag, true);
    node.removeEventListener("wheel", rescaleWithWheel, true);
  };
}
var usePointerEvents = process.browser && !!import_detect_pointer_events.default.maxTouchPoints;
var panHandler = usePointerEvents ? withPointers : withMouse;

// node_modules/svelte-image-encoder/src/ImgEncoder.svelte
var file = "node_modules/svelte-image-encoder/src/ImgEncoder.svelte";
function add_css(target) {
  append_styles(target, "svelte-1phn27w", "canvas.svelte-1phn27w{touch-action:none;position:relative}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSW1nRW5jb2Rlci5zdmVsdGUiLCJzb3VyY2VzIjpbIkltZ0VuY29kZXIuc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzY3JpcHQ+XHJcblx0aW1wb3J0IHsgcGFuSGFuZGxlciB9IGZyb20gJy4vcGFuLXpvb20nO1xyXG5cdGltcG9ydCB7IG9uTW91bnQgfSBmcm9tICdzdmVsdGUnO1xyXG5cdGV4cG9ydCBsZXQgc3JjID0gJyc7XHJcblx0ZXhwb3J0IGxldCB1cmwgPSAnJztcclxuXHRleHBvcnQgbGV0IHF1YWxpdHkgPSAwLjU7XHJcblx0ZXhwb3J0IGxldCB3aWR0aCA9IDI1NjtcclxuXHRleHBvcnQgbGV0IGhlaWdodCA9IDI1NjtcclxuXHRleHBvcnQgbGV0IHJlYWxUaW1lID0gZmFsc2U7XHJcblx0ZXhwb3J0IGxldCBjcm9zc09yaWdpbiA9IGZhbHNlO1xyXG5cdGV4cG9ydCBsZXQgY2xhc3NlcyA9ICcnO1xyXG5cdC8vZXhwb3J0IGxldCBzaG93UmVzdWx0ID0gdHJ1ZTsgXHJcblx0Ly9UT0RPOiBhZGQgc3VwcG9ydCBmb3Igb3B0aW9uYWxseSBzaG93aW5nIGNvbXByZXNzZWQgcmVzdWx0IGluc3RlYWQgb2Ygb3JpZ2luYWxcclxuXHRwYW5IYW5kbGVyOyAvL21lbnRpb25lZCBzbyB0aGF0IHRoZSBUeXBlc2NyaXB0IGNvbXBpbGVyIGVtaXRzIHRoZSBpbXBvcnQuXHJcblx0bGV0IGNhbnZhcztcclxuXHRsZXQgaW1nO1xyXG5cdGxldCBjdHg7XHJcblx0bGV0IG9mZnNldFggPSAwO1xyXG5cdGxldCBvZmZzZXRZID0gMDtcclxuXHRsZXQgc2NhbGUgPSAxO1xyXG5cdGxldCBtaW5TY2FsZSA9IDE7XHJcblx0bGV0IGRyYWdnaW5nID0gZmFsc2U7XHJcblx0Ly8gbm90IGEgUE9KTyBiZWNhdXNlIGdldHRlcnMvc2V0dGVycyBhcmUgaW5zdHJ1bWVudGFibGUgYnkgU3ZlbHRlXHJcblx0Ly8gYW5kIGB0cmFuc2Zvcm1gIGlzIHVwZGF0ZWQgYnkgaW1wb3J0ZWQgZnVuY3Rpb25zXHJcblx0bGV0IHRyYW5zZm9ybSA9IHtcclxuXHRcdGdldE1pblNjYWxlKCkge1xyXG5cdFx0XHRyZXR1cm4gbWluU2NhbGU7XHJcblx0XHR9LFxyXG5cdFx0Z2V0U2NhbGUoKSB7XHJcblx0XHRcdHJldHVybiBzY2FsZTtcclxuXHRcdH0sXHJcblx0XHRzZXRTY2FsZShzKSB7XHJcblx0XHRcdHNjYWxlID0gcztcclxuXHRcdH0sXHJcblx0XHRnZXRPZmZzZXRYKCkge1xyXG5cdFx0XHRyZXR1cm4gb2Zmc2V0WDtcclxuXHRcdH0sXHJcblx0XHRnZXRPZmZzZXRZKCkge1xyXG5cdFx0XHRyZXR1cm4gb2Zmc2V0WTtcclxuXHRcdH0sXHJcblx0XHRzZXRPZmZzZXRYKG94KSB7XHJcblx0XHRcdG9mZnNldFggPSBveDtcclxuXHRcdH0sXHJcblx0XHRzZXRPZmZzZXRZKG95KSB7XHJcblx0XHRcdG9mZnNldFkgPSBveTtcclxuXHRcdH0sXHJcblx0XHRzZXREcmFnZ2luZyhkKSB7XHJcblx0XHRcdGlmICghcmVhbFRpbWUgJiYgZCA9PT0gZmFsc2UpXHJcblx0XHRcdFx0dXJsID0gY2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvanBlZycsIHF1YWxpdHkpO1xyXG5cdFx0XHRkcmFnZ2luZyA9IGQ7XHJcblx0XHR9LFxyXG5cdFx0Z2V0RHJhZ2dpbmcoKSB7XHJcblx0XHRcdHJldHVybiBkcmFnZ2luZztcclxuXHRcdH1cclxuXHR9O1xyXG5cdGZ1bmN0aW9uIHJlZHJhdygpIHtcclxuXHRcdGlmICghaW1nIHx8ICFjdHgpXHJcblx0XHRcdHJldHVybjtcclxuXHRcdGlmIChvZmZzZXRYIDwgMClcclxuXHRcdFx0b2Zmc2V0WCA9IDA7XHJcblx0XHRpZiAob2Zmc2V0WSA8IDApXHJcblx0XHRcdG9mZnNldFkgPSAwO1xyXG5cdFx0bGV0IGxpbWl0ID0gaW1nLndpZHRoICogc2NhbGUgLSB3aWR0aDtcclxuXHRcdGlmIChvZmZzZXRYID4gbGltaXQpXHJcblx0XHRcdG9mZnNldFggPSBsaW1pdDtcclxuXHRcdGxpbWl0ID0gaW1nLmhlaWdodCAqIHNjYWxlIC0gaGVpZ2h0O1xyXG5cdFx0aWYgKG9mZnNldFkgPiBsaW1pdClcclxuXHRcdFx0b2Zmc2V0WSA9IGxpbWl0O1xyXG5cdFx0Y3R4LnJlc2V0VHJhbnNmb3JtKCk7XHJcblx0XHRjdHguY2xlYXJSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xyXG5cdFx0Y3R4LnRyYW5zbGF0ZSgtb2Zmc2V0WCwgLW9mZnNldFkpO1xyXG5cdFx0Y3R4LnNjYWxlKHNjYWxlLCBzY2FsZSk7XHJcblx0XHRjdHguZHJhd0ltYWdlKGltZywgMCwgMCk7XHJcblx0XHRpZiAocmVhbFRpbWUgfHwgIWRyYWdnaW5nKVxyXG5cdFx0XHR1cmwgPSBjYW52YXMudG9EYXRhVVJMKCdpbWFnZS9qcGVnJywgcXVhbGl0eSk7XHJcblx0fVxyXG5cdCQ6IGltZyAmJiAoaW1nLmNyb3NzT3JpZ2luID0gY3Jvc3NPcmlnaW4gPyAnYW5vbnltb3VzJyA6IG51bGwpO1xyXG5cdCQ6IGltZyAmJiAoaW1nLnNyYyA9IHNyYyk7XHJcblx0JDogcXVhbGl0eSwgd2lkdGgsIGhlaWdodCwgb2Zmc2V0WCwgb2Zmc2V0WSwgc2NhbGUsIHJlZHJhdygpO1xyXG5cdG9uTW91bnQoKCkgPT4ge1xyXG5cdFx0Y3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcblx0XHRpbWcgPSBuZXcgSW1hZ2UoKTtcclxuXHRcdGltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdG9mZnNldFggPSAwO1xyXG5cdFx0XHRvZmZzZXRZID0gMDtcclxuXHRcdFx0c2NhbGUgPSBtaW5TY2FsZSA9IE1hdGgubWF4KHdpZHRoIC8gaW1nLndpZHRoLCBoZWlnaHQgLyBpbWcuaGVpZ2h0KTtcclxuXHRcdH07XHJcblx0fSk7XHJcbjwvc2NyaXB0PlxyXG5cclxuPGNhbnZhcyBiaW5kOnRoaXM9e2NhbnZhc30ge3dpZHRofSB7aGVpZ2h0fSBjbGFzcz17Y2xhc3Nlc30gdXNlOnBhbkhhbmRsZXI9e3RyYW5zZm9ybX0+PC9jYW52YXM+XHJcblxyXG48c3R5bGU+XHJcblx0Y2FudmFzIHtcclxuXHRcdHRvdWNoLWFjdGlvbjogbm9uZTtcclxuXHRcdHBvc2l0aW9uOiByZWxhdGl2ZTtcclxuXHR9XHJcbjwvc3R5bGU+XHJcblxyXG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBNkZDLE1BQU0sZUFBQyxDQUFDLEFBQ1AsWUFBWSxDQUFFLElBQUksQ0FDbEIsUUFBUSxDQUFFLFFBQVEsQUFDbkIsQ0FBQyJ9 */");
}
function create_fragment(ctx) {
  let canvas_1;
  let canvas_1_class_value;
  let panHandler_action;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      canvas_1 = element("canvas");
      attr_dev(
        canvas_1,
        "width",
        /*width*/
        ctx[0]
      );
      attr_dev(
        canvas_1,
        "height",
        /*height*/
        ctx[1]
      );
      attr_dev(canvas_1, "class", canvas_1_class_value = null_to_empty(
        /*classes*/
        ctx[2]
      ) + " svelte-1phn27w");
      add_location(canvas_1, file, 90, 0, 2200);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, canvas_1, anchor);
      ctx[14](canvas_1);
      if (!mounted) {
        dispose = action_destroyer(panHandler_action = panHandler.call(
          null,
          canvas_1,
          /*transform*/
          ctx[4]
        ));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*width*/
      1) {
        attr_dev(
          canvas_1,
          "width",
          /*width*/
          ctx2[0]
        );
      }
      if (dirty & /*height*/
      2) {
        attr_dev(
          canvas_1,
          "height",
          /*height*/
          ctx2[1]
        );
      }
      if (dirty & /*classes*/
      4 && canvas_1_class_value !== (canvas_1_class_value = null_to_empty(
        /*classes*/
        ctx2[2]
      ) + " svelte-1phn27w")) {
        attr_dev(canvas_1, "class", canvas_1_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(canvas_1);
      ctx[14](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ImgEncoder", slots, []);
  let { src = "" } = $$props;
  let { url = "" } = $$props;
  let { quality = 0.5 } = $$props;
  let { width = 256 } = $$props;
  let { height = 256 } = $$props;
  let { realTime = false } = $$props;
  let { crossOrigin = false } = $$props;
  let { classes = "" } = $$props;
  panHandler;
  let canvas;
  let img;
  let ctx;
  let offsetX = 0;
  let offsetY = 0;
  let scale = 1;
  let minScale = 1;
  let dragging = false;
  let transform = {
    getMinScale() {
      return minScale;
    },
    getScale() {
      return scale;
    },
    setScale(s) {
      $$invalidate(13, scale = s);
    },
    getOffsetX() {
      return offsetX;
    },
    getOffsetY() {
      return offsetY;
    },
    setOffsetX(ox) {
      $$invalidate(11, offsetX = ox);
    },
    setOffsetY(oy) {
      $$invalidate(12, offsetY = oy);
    },
    setDragging(d) {
      if (!realTime && d === false)
        $$invalidate(5, url = canvas.toDataURL("image/jpeg", quality));
      dragging = d;
    },
    getDragging() {
      return dragging;
    }
  };
  function redraw() {
    if (!img || !ctx)
      return;
    if (offsetX < 0)
      $$invalidate(11, offsetX = 0);
    if (offsetY < 0)
      $$invalidate(12, offsetY = 0);
    let limit = img.width * scale - width;
    if (offsetX > limit)
      $$invalidate(11, offsetX = limit);
    limit = img.height * scale - height;
    if (offsetY > limit)
      $$invalidate(12, offsetY = limit);
    ctx.resetTransform();
    ctx.clearRect(0, 0, width, height);
    ctx.translate(-offsetX, -offsetY);
    ctx.scale(scale, scale);
    ctx.drawImage(img, 0, 0);
    if (realTime || !dragging)
      $$invalidate(5, url = canvas.toDataURL("image/jpeg", quality));
  }
  onMount(() => {
    ctx = canvas.getContext("2d");
    $$invalidate(10, img = new Image());
    $$invalidate(
      10,
      img.onload = function() {
        $$invalidate(11, offsetX = 0);
        $$invalidate(12, offsetY = 0);
        $$invalidate(13, scale = minScale = Math.max(width / img.width, height / img.height));
      },
      img
    );
  });
  const writable_props = [
    "src",
    "url",
    "quality",
    "width",
    "height",
    "realTime",
    "crossOrigin",
    "classes"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ImgEncoder> was created with unknown prop '${key}'`);
  });
  function canvas_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      canvas = $$value;
      $$invalidate(3, canvas);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("src" in $$props2)
      $$invalidate(6, src = $$props2.src);
    if ("url" in $$props2)
      $$invalidate(5, url = $$props2.url);
    if ("quality" in $$props2)
      $$invalidate(7, quality = $$props2.quality);
    if ("width" in $$props2)
      $$invalidate(0, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(1, height = $$props2.height);
    if ("realTime" in $$props2)
      $$invalidate(8, realTime = $$props2.realTime);
    if ("crossOrigin" in $$props2)
      $$invalidate(9, crossOrigin = $$props2.crossOrigin);
    if ("classes" in $$props2)
      $$invalidate(2, classes = $$props2.classes);
  };
  $$self.$capture_state = () => ({
    panHandler,
    onMount,
    src,
    url,
    quality,
    width,
    height,
    realTime,
    crossOrigin,
    classes,
    canvas,
    img,
    ctx,
    offsetX,
    offsetY,
    scale,
    minScale,
    dragging,
    transform,
    redraw
  });
  $$self.$inject_state = ($$props2) => {
    if ("src" in $$props2)
      $$invalidate(6, src = $$props2.src);
    if ("url" in $$props2)
      $$invalidate(5, url = $$props2.url);
    if ("quality" in $$props2)
      $$invalidate(7, quality = $$props2.quality);
    if ("width" in $$props2)
      $$invalidate(0, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(1, height = $$props2.height);
    if ("realTime" in $$props2)
      $$invalidate(8, realTime = $$props2.realTime);
    if ("crossOrigin" in $$props2)
      $$invalidate(9, crossOrigin = $$props2.crossOrigin);
    if ("classes" in $$props2)
      $$invalidate(2, classes = $$props2.classes);
    if ("canvas" in $$props2)
      $$invalidate(3, canvas = $$props2.canvas);
    if ("img" in $$props2)
      $$invalidate(10, img = $$props2.img);
    if ("ctx" in $$props2)
      ctx = $$props2.ctx;
    if ("offsetX" in $$props2)
      $$invalidate(11, offsetX = $$props2.offsetX);
    if ("offsetY" in $$props2)
      $$invalidate(12, offsetY = $$props2.offsetY);
    if ("scale" in $$props2)
      $$invalidate(13, scale = $$props2.scale);
    if ("minScale" in $$props2)
      minScale = $$props2.minScale;
    if ("dragging" in $$props2)
      dragging = $$props2.dragging;
    if ("transform" in $$props2)
      $$invalidate(4, transform = $$props2.transform);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*img, crossOrigin*/
    1536) {
      $:
        img && $$invalidate(10, img.crossOrigin = crossOrigin ? "anonymous" : null, img);
    }
    if ($$self.$$.dirty & /*img, src*/
    1088) {
      $:
        img && $$invalidate(10, img.src = src, img);
    }
    if ($$self.$$.dirty & /*quality, width, height, offsetX, offsetY, scale*/
    14467) {
      $:
        quality, width, height, offsetX, offsetY, scale, redraw();
    }
  };
  return [
    width,
    height,
    classes,
    canvas,
    transform,
    url,
    src,
    quality,
    realTime,
    crossOrigin,
    img,
    offsetX,
    offsetY,
    scale,
    canvas_1_binding
  ];
}
var ImgEncoder = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        src: 6,
        url: 5,
        quality: 7,
        width: 0,
        height: 1,
        realTime: 8,
        crossOrigin: 9,
        classes: 2
      },
      add_css
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ImgEncoder",
      options,
      id: create_fragment.name
    });
  }
  get src() {
    throw new Error("<ImgEncoder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set src(value) {
    throw new Error("<ImgEncoder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get url() {
    throw new Error("<ImgEncoder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set url(value) {
    throw new Error("<ImgEncoder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get quality() {
    throw new Error("<ImgEncoder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set quality(value) {
    throw new Error("<ImgEncoder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<ImgEncoder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<ImgEncoder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<ImgEncoder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<ImgEncoder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get realTime() {
    throw new Error("<ImgEncoder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set realTime(value) {
    throw new Error("<ImgEncoder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get crossOrigin() {
    throw new Error("<ImgEncoder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set crossOrigin(value) {
    throw new Error("<ImgEncoder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get classes() {
    throw new Error("<ImgEncoder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set classes(value) {
    throw new Error("<ImgEncoder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ImgEncoder_default = ImgEncoder;
export {
  ImgEncoder_default as default
};
//# sourceMappingURL=svelte-image-encoder.js.map
